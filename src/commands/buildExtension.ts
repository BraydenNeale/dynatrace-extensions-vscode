import * as vscode from "vscode";
import * as path from "path";
import AdmZip = require("adm-zip");
import * as yaml from "yaml";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "fs";
import { sign } from "../utils/cryptography";
import { checkValidExtensionName } from "../utils/conditionCheckers";

/**
 * Builds an Extension 2.0 and its artefacts into a .zip package ready to upload to Dynatrace.
 * The extension files must all be in an extension folder in the workspace, and developer
 * certificates must be available - either from settings (via file paths) or generated
 * through this extension. If successful, the command is linked to uploading the package
 * to Dynatrace.
 * Note: Only custom extensions may be built/signed using this method.
 * @param context VSCode Extension Context
 * @returns
 */
export async function buildExtension(context: vscode.ExtensionContext) {
  const workspaceRoot = vscode.workspace.workspaceFolders![0].uri.fsPath;

  // Create the dist folder if it doesn't exist
  const distDir = path.resolve(workspaceRoot, "dist");
  if (!existsSync(distDir)) {
    mkdirSync(distDir);
  }
  // Certificates can be generated by us
  let devKeyPath = path.resolve(context.storageUri!.fsPath, "certificates", "dev.key");
  let devCertPath = path.resolve(context.storageUri!.fsPath, "certificates", "dev.pem");

  // Or the user's own ones
  if (!existsSync(devCertPath) || !existsSync(devKeyPath)) {
    devKeyPath = path.resolve(
      vscode.workspace.getConfiguration().get("dynatrace.certificate.location.developerKey") as string
    );
    devCertPath = path.resolve(
      vscode.workspace.getConfiguration().get("dynatrace.certificate.location.developerCertificate") as string
    );
  }

  // Extension meta
  const extensionFile = await vscode.workspace
    .findFiles("**/extension/extension.yaml")
    .then((files) => files[0].fsPath);
  const extensionDir = path.resolve(extensionFile, "..");
  const extension = yaml.parse(readFileSync(extensionFile).toString());
  // We can only build custom extensions this way
  if (!checkValidExtensionName(extension.name)) {
    vscode.window.showErrorMessage("Build extension: operation aborted.");
    return;
  }

  // Build the inner .zip archive
  const innerZip = new AdmZip();
  innerZip.addLocalFolder(extensionDir);
  const innerZipPath = path.resolve(context.storageUri!.fsPath, "extension.zip");
  innerZip.writeZip(innerZipPath);
  console.log(`Built the inner archive: ${innerZipPath}`);

  // Sign the inner .zip archive and write the signature file
  const signature = sign(innerZipPath, distDir, devKeyPath, devCertPath);
  const sigatureFilePath = path.resolve(context.storageUri!.fsPath, "extension.zip.sig");
  writeFileSync(sigatureFilePath, signature);
  console.log(`Wrote the signature file: ${sigatureFilePath}`);

  // Build the outer .zip that includes the inner .zip and the signature file
  const outerZip = new AdmZip();
  const outerZipPath = path.join(distDir, `${extension.name.replace(":", "_")}-${extension.version}.zip`);
  outerZip.addLocalFile(innerZipPath);
  outerZip.addLocalFile(sigatureFilePath);
  outerZip.writeZip(outerZipPath);
  console.log(`Wrote the outer zip: ${outerZipPath}`);

  // Link to the upload command
  vscode.window
    .showInformationMessage("Extension built successfully. Would you like to upload it to Dynatrace?", "Yes", "No")
    .then((choice) => {
      if (choice === "Yes") {
        vscode.commands.executeCommand("dynatrace-extension-developer.uploadExtension");
      }
    });
}
